# Comentários Gerais sobre Resolução do Exercício
Em relação a tua preocupação com os caminhos fixos e hardcode e tal como falamos, num próximo faremos com leitura do arquivo de config, então quanto a isso fica tranquilo. <br/><br/>
A tua lógica dos "Ifs" de validação está boa, porém faltou uma validação, que vou detalhar melhor mais abaixo. <br/><br/>
O uso de um form não era necessário para esse caso, mas fica como um "plus a mais", apesar de ele ser apenas informativo. <br/><br/>
**Tua solução resolveu o problema proposto, logo o objetivo foi cumprido. Muito bom!** <br/><br/>

# Detalhes que acho importante comentar
1. Se tu apenas passar esse programa pro cliente e ele tentar executar, provavelmente vai dar erro de cara, porque o cliente não sabe que precisa ter uma pasta chamada *"Arquivos"* e dentro dela a pasta *"Examples"* como fizeste. O ideal seria que os arquivos fossem lidos de apenas 1 pasta ou até mesmo da pasta onde está o exe, daí tu poderia dizer "joga esse exe dentro da pasta onde estão teus arquivos e roda" ou "cria uma pasta Arquivos, joga os teus txt dentro e roda".
2. Faltou fazer a validação se o código do cliente é inexistente em relação aos que foram passados no enunciado. Hoje, se o código não for nenhum deles, no teu método *GetCliente*, ele simplesmente retorna null, mas tu não faz nada com esse null e deveria logar dizendo que o código não foi encontrado.
3. O uso de classes e Enums foi bacana, porém tenta se habituar a criar as classes com nomes que definam o que elas são, mesmo quando for um problema simples como esse aqui que propus. "OBJETO" não me diz nada lendo o fonte, eu preciso interpretar ou até mesmo abrir a classe pra saber do que se trata.
4. Ainda sobre as classes, tu criou uma pasta para UI mas as classes ficaram soltas na raiz do projeto. Se for separar por pastas, ideal é separar tudo ou nada, 8 ou 80. E também, em relação aos nomes, ou usa todas com nome todo **<u>UPPERCASE</u>** ou todas com nome **<u>CamelCase</u>**, tenta não misturar, pois senão fica ruim a leitura do código (é meio que um TOCzinho meu, mas sempre bom manter coêrencia no fonte).
5. Nas validações, foi interessante separar elas em um método, pois fica, de certa forma reaproveitável. Mas como o exercício contém poucas validações, **EU** faria elas dentro do loop mesmo, mas aí é uma questão de preferência mesmo.
6. As mensages de sucesso ou erro precisam ser mais claras. Entendo que era pra deixar bem simples tudo, porém ficou simples **demais** os avisos, tanto de sucesso quanto de problemas. No de erro, poderia ao menos informar o path onde foi gravado o log de erros, pro cliente ficar ciente onde ele pode ver o que aconteceu de problemas.
7. A verificação de diretório inexistente (linha 84), poderia ser apenas um MessageBox e um return false, sem a necessidade de salvar na variável de erro e depois escrever no log. Se o diretório não existir, o programa no caso deveria abortar completamente a execução, sem necessidade de logar nada.
8. Todos os teus MessageBox estão sem o segundo e terceiro parâmetros, que é o _Caption_ e o _Ícone_, dessa forma o C# gera janelas de alerta sem título e sem nenhuma informação se é um Warning ou erro, daí não fica claro pro cliente.
9. Depois do Valida (linha 95), tu poderia ter armazenzado o arquivoLido[0] em uma variável, com nome por exemplo de "header" ou "primeiraLinha", etc... pois assim, poderia usar ela mais abaixo, sem precisar escrever mais vezes o "arquivoLido[0]". Aqui é mais uma dica de clean code mesmo.
10. A tua prop "TipoArquivo" do objeto não serve pra nada no contexto do programa que foi escrito, ela está somente informativa. O CodCliente também está na mesma situação, tu usa ele para passar pro método GetNomeCliente, mas no objeto em si, ele não tem nenhum uso expressivo, dá no mesmo que passar o valor lido direto da string.
11. No C#, pra fazer concatenação de paths para qualquer coisa, ideal é usar a lib Path.Combine, pois ela já adiciona as barras ao final de cada path, e tu não precisa se preocupar com isso e ficar concatenando strings na mão grande usando @. Por exemplo, se tu fizer isso --> Path.Combine(Application.StartupPath, "Arquivos", "Examples") o resultado será o mesmo que fazendo Application.StartupPath + @"\Arquivos\Examples\", mas sem precisar concatenar e te preocupar se colocou a barra no final ou não, o que pode ferrar a execução ou localização do caminho de qualquer coisa.
12. Tu está usando no final Directory.Move, mas tu precisa mover apenas o arquivo TXT, então o correto seria usar File.Move(pathOrigem, pathDestino). Ele funciona, mas novamente, fica incoerente, pois tu não quer mover um diretório e sim um arquivo.
13. No teu método ButtonClick (sacanagem isso aqui heinhô mas vou deixar passar), tu verifica se a string error != string.Empty, porém em outras validações de string tu usou string.IsNullOrWhiteSpace, novamente, cuida a coerência. Ou usa todos de um jeito ou do outro, evita misturar. E não esquece que "erro != string.Empty" vai dar pau se a string for NULL ;).
14. Outra diquinha pra melhorar a leitura de código: métodos que validam TRUE não precisa colocar "if(minhaValidacao == true)", pode ser apenas "if(minhaValidacao)", principalmente se o método que está dentro tem um nome sugestivo. Se o retorno dele for TRUE, ele vai entrar no teu IF.
15. Para pegar o tipo do arquivo, tu poderia ter salvo o substring de (0,4) dele numa variável também, tipo "tipoArquivo" e tal, pra depois usar. Como falei na dica 9, ai evita de ficar escrevendo explicitamente esse cara várias e várias vezes e teria um uso pro teu Enum talvez.
16. Teu Try/Catch não está fazendo nada também, caso ocorra algum erro que caia lá, ele simplesmente sobe um Throw e já era, não loga, não avisa e vai derrubar o programa.


